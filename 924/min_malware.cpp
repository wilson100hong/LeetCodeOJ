// Find island with single malware.
#include <iostream>
#include <vector>
#include <unordered_set>
#include <set>
#include <algorithm>
using namespace std;

class DisjointSet {
public:
  DisjointSet(int n) {
    group_.assign(n+1, 0);  // [n] for maleware sink
    for (int i=0;i<group_.size();i++) {
      group_[i] = i;
    }
    size_.assign(n+1, 1);
    size_[n] = 0;
  }

  DisjointSet(const DisjointSet& ds) {
    group_ = ds.group_;
    size_ = ds.size_;
  }

  int find(int u) {
    if (group_[u] != u) {
      group_[u] = find(group_[u]);
    }
    return group_[u];
  }

  void join(int u, int v) {
    int gu = find(u), gv = find(v);
    if (gu == gv) return;
    if (size_[gu] > size_[gv]) {
      group_[gv] = gu;
      size_[gu] += size_[gv];
    } else {
      group_[gu] = gv;
      size_[gv] += size_[gu];
    }
  }

  int size(int u) {
    return size_[find(u)];
  }
private:
  vector<int> group_;
  vector<int> size_;
};

class Solution {
public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    DisjointSet ds(n);

    for (int i=0;i<n;++i) {
      //if (malwares.count(i)) continue;
      for (int j=0;j<n;++j) {
        if (i != j && graph[i][j] == 1) {
          ds.join(i, j);
        }
      }
    }

    vector<int> num_mals(n, 0);
    for (int m : initial) {
      num_mals[ds.find(m)]++;
    }

    // size, index
    pair<int, int> best = {-1, -1};
    for (int m : initial) {
      pair<int, int> temp;
      if (num_mals[ds.find(m)] == 1) {
        temp = {ds.size(m), m};
      } else {
        temp = {0, m};
      }
      if (temp.first > best.first) {
        best = temp;
      } else if (temp.first == best.first) {
        best.second = min(best.second, temp.second);
      }
    }
    return best.second;
  }
};

int main() {
  vector<vector<int>> graph = {
    //{1,1,0},{1,1,0},{0,0,1}
    //{1,0,0},{0,1,0},{0,0,1}
    {1,1,1},{1,1,1},{1,1,1}
  };
  vector<int> initial = {
    1,2
  };
  Solution sol;
  cout << sol.minMalwareSpread(graph, initial) << endl;
}
