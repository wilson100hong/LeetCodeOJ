// 1. Return index of node, not the index in initial list.
// 2. Be careful to skip unwanted element
// 3. Count virus with a sink
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class DisjointSet {
public:
  DisjointSet(int n) {
    // [n] for virus machine.
    group_.assign(n+1, -1);
    for (int i=0;i<group_.size();++i) group_[i] = i;
    size_.assign(n+1, 1);
    size_[n] = 0;
  }

  DisjointSet(const DisjointSet& ds) {
    group_ = ds.group_;
    size_ = ds.size_;
  }

  int find(int u) {
    if (group_[u] != u) {
      group_[u] = find(group_[u]);
    }
    return group_[u];
  }

  void join(int u, int v) {
    int gu = find(u), gv = find(v);
    if (gu == gv) return;
    if (size_[gu] > size_[gv]) {
      group_[gv] = gu;
      size_[gu] += size_[gv];
    } else {
      group_[gu] = gv;
      size_[gv] += size_[gu];
    }
  }

  int size(int u) {
    return size_[find(u)];
  }
private:
  vector<int> group_;
  vector<int> size_;

};

class Solution {
public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    DisjointSet ds(n);

    sort(initial.begin(), initial.end());
    
    vector<bool> skip(n, false);
    for (int m : initial) skip[m] = true;
    for (int i=0;i<n;++i) {
      if (skip[i]) continue;
      for (int j=0;j<n;++j) {
        if (i == j || graph[i][j] == 0 || skip[j]) continue;
        ds.join(i, j);
      }
    }

    int best_ans = n+1;
    int best_node = -1;
    for (int m : initial) {  // m will be removed from network
      DisjointSet ds_copy(ds);
      for (int r : initial) {
        if (r == m) continue;  // skip m
        ds_copy.join(r, n);  // join with virus sink
        for (int j=0;j<n;++j) {
          if (j == m) continue;  // skip m
          if (graph[r][j]) {
            ds_copy.join(r, j);
          }
        }
      }
      int ans = ds_copy.size(n);
      //cout << "m: " << m << ", ans: " << ans << endl;

      if (ans < best_ans) {
        best_ans = ans;
        best_node = m;
      }
    }
    return best_node;
  }
};

int main() {
  vector<vector<int>> graph = {
    //{1,1,0},{1,1,0},{0,0,1}
    //{1,1,0},{1,1,1},{0,1,1}
    //{1,1,0,0},{1,1,1,0},{0,1,1,1},{0,0,1,1}
    //{1,1,1,0},{1,1,0,0},{1,0,1,0},{0,0,0,1}
    {1,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0,0},{0,0,1,0,1,0,1,0,0},{0,0,0,1,0,0,0,0,0},{0,0,1,0,1,0,0,0,0},{0,0,0,0,0,1,0,0,0},{0,0,1,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,0},{0,0,0,0,0,0,0,0,1}
  };
  vector<int> initial = {
    //0, 1
    //3,2
    0,4,6
  };
  Solution sol;
  cout << sol.minMalwareSpread(graph, initial) << endl;
}
